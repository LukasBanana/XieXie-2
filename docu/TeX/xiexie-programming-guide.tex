%----------------------------------------------------------------------------------------
%	XieXie Programming Guide TeX File
%----------------------------------------------------------------------------------------

\documentclass{report}


%----------------------------------------------------------------------------------------
%	PACKAGES
%----------------------------------------------------------------------------------------

\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{pxfonts}
\usepackage{geometry}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{hyperref}
\usepackage{xspace}

\geometry{
	a4paper,
	top=20mm,
	bottom=20mm
}

\hypersetup{
	colorlinks = true, % Colors links instead of ugly boxes
	urlcolor = blue, % Color of external hyperlinks
	linkcolor = blue, % Color of internal links
	citecolor = blue % Color of citations
}

\definecolor{brightBlueColor}{rgb}{0.5, 0.5, 1.0}
\definecolor{darkBlueColor}{rgb}{0.0, 0.0, 0.5}

\lstset{
	language = C++,
	basicstyle = \footnotesize\ttfamily,
	commentstyle = \itshape\color{brightBlueColor},
	keywordstyle = \bfseries\color{darkBlueColor},
	stringstyle = \color{red},
	frame = single,
	tabsize = 4,
	numbers=left
}

\lstset{
	morekeywords = {
		var, super, foreach, forever, init, release, and, or, not, null,
		import
	}
}

\def\xiexie{\textsc{Xi\`eXie}\xspace}
\def\xxlang{\xiexie programming language\xspace}
\def\cpp{\textsc{C++}\xspace}
\def\cppx{\textsc{C++11}\xspace}
\def\java{\textsc{Java}\xspace}
\def\python{\textsc{Python}\xspace}
\def\xxc{\texttt{xxc}\xspace}
\def\xvm{\texttt{xvm}\xspace}


%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{\xiexie Programming Guide}
\author{Lukas \textsc{Hermanns}}
\date{\today}

\begin{document}

\maketitle


%----------------------------------------------------------------------------------------
%	ABOUT THE AUTHOR
%----------------------------------------------------------------------------------------

\chapter*{About the Author}

My name is Lukas Hermanns (age-group 1990) and I started this project during my studies in 2014.
By now I have over 12 years of experience in computer programming, started at the age of 12.
I have been writing programs in Basic languages such as \textsc{QBasic}, \textsc{PureBasic}, and \textsc{Blitz3D};
in high level languages such as \textsc{C}, \textsc{C++}, \textsc{C\#}, \textsc{Objective-C}, and \textsc{Java};
but also in scripting languages such as \textsc{JavaScript} and \textsc{Python}.
I'm actually a preferred programmer in C++ (meanwhile \cppx), low level stuff, and graphics programming
with shading languages such as GLSL and HLSL.

However, the \xxlang is intended to be simple and not tuned for performance.
It was originally designed to be used for scripting in video games, but can also be used for
general purposes.

If you like, you can follow me on \href{https://twitter.com/LukasBanana}{Twitter},
\href{https://www.youtube.com/user/SoftPixel}{YouTube}, \href{https://github.com/LukasBanana}{GitHub},
or \href{https://bitbucket.org/LukasBanana}{Bitbucket}.

\tableofcontents


%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\chapter{Introduction}

First of all, ``xi\`exie'' is the chinese word for ``thanks'' or ``thank you''
(see \href{http://dictionary.hantrainerpro.com/chinese-english/translation-xiexie_thankyou.htm}{hantrainerpro.com})
and is roughly pronounced ``Sh-eh sh-eh''.

The design of the \xxlang is overall influenced by \java, \cpp, and \python.


%----------------------------------------------------------------------------------------
%	WHAT IS XIEXIE?
%----------------------------------------------------------------------------------------

\section{What is \xiexie?}

The \xiexie programming language is a high-level, object-oriented, scripting language with compiler and virtual machine.
The \xiexie compiler (XXC) translates the \xiexie code (XX) to a virtual assembler (XASM), then assembles it to
\xiexie byte code (XBC), which can then be interpreted by the \xiexie virtual machine (XVM).


%----------------------------------------------------------------------------------------
%	WHY IS IT CALLED XIEXIE?
%----------------------------------------------------------------------------------------

\section{Why is it called ``\xiexie''?}

Some years, before I started with the development of this compiler, I already had some ideas about a name for it
--- at this time the compiler was intended to be a cross compiler, i.e. to compile the \xiexie code to \cpp.
The first idea I had in mind, was to call it ``C+=2'' or ``C++++'' because it should be a more comfortable and easier
\cpp variant. But this name looked and sounded strange. Another idea was to call it ``C power of C''
(in mathematical notation $C^C$). But that still was not what I was looking for.
Then I remembered me to the Chinese word ``Xi\`exie'' which means ``Thanks'' in English and it sounds a little
similar to ``CC'' which could be seen as a shortcut for $C^C$. That's the \xiexie compiler's story about its name.

Or to make a long story short: I saw this word on a napkin in a Chinese restaurant and thought to my self: That's it! :-)


%----------------------------------------------------------------------------------------
%	MOTIVATION
%----------------------------------------------------------------------------------------

\section{Motivation}

There are many great programming languages out there. Some produce faster code than others, but some
are simpler and have a better learning curve. Using a new language doesn't mean to give up a previous one,
because every language has its own domain. For example, the performance of interpreted languages such as \python
is totally sufficient for many applications. We don't need maximal performance for a script which does some
socket connection or text processing for instance.
But I would not write the compiler and interpreter for \python in a scripted language.
There are also many ways to combine several languages: an interpreter could be used for scripting in video games
for instance. But the game engine is written in \cpp.
This is how it is done in \textsc{Unity3D} (see \href{http://www.unity3d.com/}{www.unity3d.com}).
They use \textsc{Mono} as compiler and interpreter framework for \textsc{C\#}. But the engine itself is written in \cpp.

Now \xiexie is aimed to be used for small scripting purposes, with a gentle learning curve.
The great thing about its interpreter is, that it is very tiny and can easily be integrated into
existing \textsc{C} or \cpp code. This virtual machine only consists of a single code file (written in \textsc{C99})
and can simply be included into any \textsc{C99} compliant project.


%----------------------------------------------------------------------------------------
%	SYNTAX
%----------------------------------------------------------------------------------------

\chapter{Syntax}

The we start out with the syntax.


%----------------------------------------------------------------------------------------
%	BASICS
%----------------------------------------------------------------------------------------

\section{Basics}

\subsection{Commentaries}

Commentaries are a fundamental part of programming languages and they are nearly identical to those
in \java:
\begin{lstlisting}
// Single-line comment

/* Single-line comment */

/*
Multi-line comment
*/
\end{lstlisting}
Although they are very similar to the commantaries in \java, nested multi-line comments are allowed as well:
\begin{lstlisting}
/*
Outer comment
/* Nested comment */
*/
\end{lstlisting}

\subsection{Identifiers}

Identifiers (for variables, classes, etc.) must only contain alpha-numeric characters and the underscore.
They must also begin with a letter or an underscore. But there is a small exception: they must not begin with
\texttt{\_\_xx\_\_}, because all identifiers with this prefix are reserved for internal use of the compiler. \\ \\
Valid identifiers are:
\begin{itemize}
	\item \texttt{\_name\_}
	\item \texttt{FooBar}
	\item \texttt{number\_of\_wheels}
	\item \texttt{Customer01}
	\item \dots
\end{itemize}
Invalid identifiers are:
\begin{itemize}
	\item \texttt{na\"{i}ve}
	\item \texttt{Foo.Bar}
	\item \texttt{number-of-wheels}
	\item \texttt{3over2}
	\item \dots
\end{itemize}

\subsection{Literals}

These are the kinds of literals:
\begin{itemize}
	\item Boolean Literal: \texttt{true}, \texttt{false}
	\item Integer Literal (Binary): e.g. \texttt{0b11001}, \texttt{0b0000}
	\item Integer Literal (Octal): e.g. \texttt{0o24}, \texttt{0o01234567}
	\item Integer Literal (Decimal): e.g. \texttt{3}, \texttt{12}, \texttt{999}, \texttt{1234567890}
	\item Integer Literal (Hexa-Decimal): e.g. \texttt{0xff}, \texttt{0x00}, \texttt{0xaB29}
	\item Float Literal: e.g. \texttt{0.0}, \texttt{3.5}, \texttt{12.482}
	\item String Literal: e.g. \texttt{"Foo Bar"}, \texttt{"Hello, World"}, \texttt{"\textbackslash n\textbackslash t"},
		\texttt{"1st fragment"\textvisiblespace"2nd fragment}
	\item Verbatim String Literal: e.g. \texttt{@"\textbackslash home\textbackslash test"}, \texttt{@"a ""b"" c"}
\end{itemize}
Integer and float literals may optionally contain the single quotation mark as digit separator, for better readability.
If it's used, all separators must satisfy the following rules:
\begin{enumerate}
	\item For decimal literals, the separators must be \textbf{three steps apart} from each other, beginning at the dot. \\
		Example: \texttt{12'345}, \texttt{3.141'592'654}, or \texttt{-27'836.283'74}.
	\item For non-decimal literals, the separators must be \textbf{four steps apart} from each other, beginning at the dot. \\
		Example: \texttt{0xff0'214b}, \texttt{0b100'1101'1011}, \texttt{0o1234'5670}
	\item A separator must not appear at the beginning or the end of the literal. \\
		Counterexample: \texttt{'123'456'}.
	\item No valid separator must be omitted. \\
		Counterexample: \texttt{1234'567'890}.
\end{enumerate}


%----------------------------------------------------------------------------------------
%	OPERATORS
%----------------------------------------------------------------------------------------

\section{Operators}

The most operators as in \java or \cpp are also available in \xiexie:
\begin{lstlisting}
/* Arithmetic Operators */
a + b   // Addition
a - b   // Substration
a * b   // Multiplication
a / b   // Division
a % b   // Modulo
a << b  // Left Shift
a >> b  // Right Shift
-a      // Negate

/* Bitwise Operators */
a & b   // Bitwise AND
a | b   // Bitwise OR
a ^ b   // Bitwise XOR
~a      // Bitwise NOT

/* Boolean Operators */
not a   // Logic NOT
a and b // Logic AND
a or b  // Logic OR

/* Relation Operators */
a = b   // Equality
a != b  // Inequality
a < b   // Less
a <= b  // Less Or Equal
a > b   // Greater
a >= b  // Greater Or Equal
\end{lstlisting}
As the interested reader may have noticed, the \textit{equality operator} is different to that in the most languages.
This is because the \textit{copy assignment} operators is \texttt{:=} and not \texttt{=}.
\begin{lstlisting}
x := 5       // ok, set x to 5
a, b, c := 4 // ok, set a, b, and c to 4
a := b := 3  // error, b := 3 is not an expression
\end{lstlisting}
In the above example \texttt{a := b := 3} is invalid, because on the right hand side of the first \texttt{:=} must be
an expression. But per definition in \xiexie \texttt{b := 3} is not an expression, but a statement!
The variable list assignment (\texttt{a, b, c := \dots}) is a comfort functionality, which is only supported for the
copy assignment.

The modify-assign operators are available as well:
\begin{lstlisting}
a += b
a -= b
a *= b
a /= b
a %= b
a <<= b
a >>= b
a &= b
a |= b
a ^= b
\end{lstlisting}
However, they are also not allowed inside another expression.


%----------------------------------------------------------------------------------------
%	TYPE DENOTERS
%----------------------------------------------------------------------------------------

\section{Type Denoters}

\subsection{Built-in Types}

There are only the following three built-in data types:
\begin{lstlisting}
bool  // Boolean type; can be `true' or `false'
int   // 32-bit signed integral type
float // 32-bit floating-point type
\end{lstlisting}

\subsection{Objects}

Types for class objects (more about classes in chapter \ref{ch:classes}) are written as follows:
\begin{lstlisting}
// Empty string
String s

// List of strings
String s1 := "Hello, World", s2 := "Foo", s3 := "Bar"
\end{lstlisting}

\subsection{Arrays}

The only generic way for lists are the built-in arrays:
\begin{lstlisting}
// Declare array objects with initializer lists
int[] intArray := { 1, 2, 3 }
float[][] floatArrayArray := { { 0.0, 1.5 }, { 3.5, 1.23 } }
String[] stringArray := { "a", "b", "c" }

// Access array elements
String s1 := stringArray[0]
String s2 := stringArray[intArray[0]]
float[] floatArray := floatArrayArray[1]
\end{lstlisting}

\subsection{Automatic Type Deduction}

Whereas automatic type deduction in \cppx is a very extensive language feature,
in \xiexie it can be summarized in this section.
There are two keywords for automatic type deduction: \texttt{var} and \texttt{const}. As the name implies
\texttt{var} denotes a variable type and \texttt{const} denotes a constant type. The latter type is the only way
to define constants in \xiexie. Here are a few examples:
\begin{lstlisting}
var   i  := 1       // i is from type 'int'
var   f  := 3.5     // f is from type 'float'
var   s  := "."     // s is from type 'String'
var   a  := { 5 }   // a is from type 'array of int'
var   aa := {       // aa is from type 'array of array of String'
  { "test" },
  { "a", "b" }
}

const ci := 5       // ci is a constnat int with value 5
const cj := ci*2    // cj is a constant int with value 10
const cf := 3.14    // cf is a constant float
const cb := ci > cj // cb is a constant bool with value 'false'
\end{lstlisting}


%----------------------------------------------------------------------------------------
%	STATEMENTS AND EXPRESSIONS
%----------------------------------------------------------------------------------------

\section{Statements and Expressions}

Unlike \cpp and \java, there are no semicolons in \xiexie to terminate statements.
Only the regular \texttt{for}-statement has two semicolons, to separate the initializer statement,
the conidition expression, and the increment statement. This means the compiler
(or rather the \textit{parser}, which reads the source code) always knows when a statement or expression is complete.
But it also means that you --- the programmer --- can do weird things with this syntax. Consider the following code sample:
\begin{lstlisting}
int a:=3
-4
,b:=-
5+2 int c
\end{lstlisting}
This is valid \xiexie code and it contains only two statements!
If we write it in a more common convention, it may look like this:
\begin{lstlisting}
int a := 3-4,
    b := -5+2
int c
\end{lstlisting}
Hence, the readability of your code is up to you and your programming style :-). The only language I've worked with,
which forces you to practice better readability is \python.
Actually a great principle, but with \xiexie you have complete freedom.

The absence of statement terminators is the reason for the \textit{double paren} syntax of attributes:
\begin{lstlisting}
[[attribute]]
\end{lstlisting}
To understand why this is the case, let's assume attributes are written with a single paren and consider
the following class declaration:
\begin{lstlisting}
class Widget {
    const c := 0 // Initialize member constant 'c' with 0
    int   v := c // Initialize member variable 'v' with constant 'c'
    [entry]      // Mark next procedure as the main entry point with attribute 'entry'
    static void main() {}
}
\end{lstlisting}
Now this doesn't seem very complex. But the parser runs into trouble when reading \texttt{[entry]}.
This is because the parser reads it as follows:
\begin{lstlisting}
int v := c[entry]
\end{lstlisting}
But \texttt{c} is not an array. This is why attributes are written with a double paren, because array accesses
never begin with '[['. They may end with ']]', but this is not important for the parser.

\subsection{Loop Statements}

It follows several examples of loop statements.

\subsubsection{\texttt{for} Loop}

\begin{lstlisting}
// This regular for loop iterates 'i' from 0 to 9 (similar to Java)
for int i := 0 ; i < 10 ; i++ {
    // Infinite loop (also similar to Java)
    for ;; {
        if i >= 0 {
            // Break infinite loop
            break
        }
    }
    
    // Inner iteration variable 'j' is implicit initialized to 0.0
    float j
    for ; j < 3.5 ; {
        j += 0.5
    }
}
\end{lstlisting}

\subsubsection{Ranged Based \texttt{for} Loop}

\begin{lstlisting}
// Print numbers 0, 1, 2, 3, and 4
for i : 0 .. 4 {
    // Print value of 'i' (this 'i' is not mutable!)
    print(i)
}

// Print numbers 10, 7, 4, 1, -2, -5, and -8
for i : 10 .. -10 -> 3 {
    print(i)
}

// Do something 10 times (with invisible index variable)
for 10 {
    doSomething()
}
\end{lstlisting}

\subsubsection{\texttt{foreach} Loop}

\begin{lstlisting}
// Iterate over array with elements 1, 2, and 3
foreach i : { 1, 2, 3 } {
    print(i)
}

// Iterate over a 'superList' from type (array of array of strings)
String[][] superList
foreach list : superList {
    // Iterate over all elements in the current sub list
    foreach str : list {
        // Do something with this string
        print(str)
    }
}
\end{lstlisting}

\subsubsection{\texttt{forever} Loop}

\begin{lstlisting}
// Infinite loop
forever {
    // Condition to break the loop
    if magicFunction() {
        // Break infinite loop
        break
    }
}
\end{lstlisting}

\subsubsection{\texttt{while} Loop}

\begin{lstlisting}
// Regular while loop
while magicFunction() {
    doSomething()
}
\end{lstlisting}

\subsubsection{\texttt{do}/\texttt{while} Loop}

\begin{lstlisting}
// Regular do-while loop
do {
    doSomething()
} while magicFunction()
\end{lstlisting}



%----------------------------------------------------------------------------------------
%	CLASSES
%----------------------------------------------------------------------------------------

\chapter{Classes}
\label{ch:classes}

A \xiexie program can only consist of imports and class declarations. And classes can only be defined in the global scope.
That means every procedure must be defined inside a class and inner classes are currently not supported.


%----------------------------------------------------------------------------------------
%	GETTING STARTED
%----------------------------------------------------------------------------------------

\section{Getting Started}

To get started, take a look at the following example program which prints the classical phrase ``Hello, World!''
onto the standard output:
\begin{lstlisting}
// XieXie Hello World Program
import System
class HelloWorld {
    [[entry]]
    static void main() {
        System.out.writeLine("Hello, World!")
    }
}
\end{lstlisting}
This merely writes the line ``\texttt{Hello, World!}'' to the standard output. Let's take a closer look at each line.

Line 2 imports the ``System.xx'' file from the \xiexie standard library:
\begin{lstlisting}
import System      // either this ...
import "System.xx" // ... or this
\end{lstlisting}
If the imported file is in another directory, the string version of \texttt{import} is the only choice.
This can also be omitted if the file is added to the compilation process.
The files for the classes \texttt{Object}, \texttt{String}, \texttt{Array}, and \texttt{Intrinsics}
are always implicit imported, because they are `internal' classes the compiler knows generally.
Note that verbatim strings are allowed wherever string literals are allowed, i.e. the following example is valid \xiexie code:
\begin{lstlisting}
import "C:\\Program Files\\Test1.xx" // either this ...
import @"C:\Program Files\Test1.xx"  // ... or this
\end{lstlisting}
The \texttt{import} keyword is different to that in \java and also different to the \texttt{\#include} directive in \cpp.
Although it takes a filename as parameter (like \cpp's \texttt{\#include}), it does not \textit{include} the file in place.
Whenever an \texttt{import} is read by the \textit{parser}, the filename is added to the set of import files.
After all source files have been read, which were passed as input to the compiler, all import files will be read next.
This will be repeated until no new files are added to the set.
Consider this is a \textit{set} of files, i.e. several \texttt{import} commands may occur with the same filename,
but it will be read only once. This is why the above sample is valid \xiexie code. It also means that recursive imports
are allowed as well:
\begin{lstlisting}
// File1.xx
import "File2.xx"
\end{lstlisting}
\begin{lstlisting}
// File2.xx
import "File1.xx"
\end{lstlisting}

Line 3 declares the class \texttt{HelloWorld} which implicit inherits from the base class \texttt{Object},
like it is done in \java:
\begin{lstlisting}
class HelloWorld { /* ... */ }
\end{lstlisting}
To inherit from other classes, just write a colon and the identifier of the base class:
\begin{lstlisting}
class SubClass : BaseClass { /* ... */ }
\end{lstlisting}
There is no multiple inheritance like in \cpp or interfaces like in \java!

The next two lines declare the procedure \texttt{main}. In line 4, in \textit{attribute} is defined
for this procedure. This makes the procedure to the main \textbf{entry point}:
\begin{lstlisting}
[[entry]]
static void main() { /* ... */ }
\end{lstlisting}
There are several attributes for class-, procedure-, or variable declarations. Currently only two attributes are supported:
\begin{lstlisting}
// class A is marked as 'deprecated'
[[deprecated]]
class A {}

// class B is marked as 'deprecated' with a hint
[[deprecated("hint...")]]
class B {
    // procedure M1 is marked as the main entry point
    [[entry]]
    static void M1() {}
    
    // procedure M2 with return type is marked as an
    // alternative entry point named "entryAlt1"
    [[entry("entryAlt1")]]
    static int M2() { return 0 }
    
    // procedure M3 with arguments 'args' is marked as
    // an alternative entry point named "entryAlt2"
    [[entry("entryAlt2")]]
    static void M3(String[] args) {}
}
\end{lstlisting}

The last line of code prints the message to the standard output:
\begin{lstlisting}
System.out.writeLine("Hello, World!")
\end{lstlisting}
\texttt{System} is a class from the standard \xiexie library, \texttt{out} is a \textit{static} member
from the type 'OutputStream', and \texttt{writeLine} is a function which takes a string as input.


%----------------------------------------------------------------------------------------
%	DECLARATION RULES FOR CLASSES
%----------------------------------------------------------------------------------------

\section{Declaration Rules for Classes}

In \xiexie there is no need for \textit{forward declarations}. Everything can be declared in the respective scope
and is accessible throughout the entire program (except private scope). This is why the following code is valid:
\begin{lstlisting}
// First declare sub class
class SubClass : BaseClass { /* ... */ }

// Then declare base class
class BaseClass { /* ... */ }
\end{lstlisting}
The same applies for procedure declarations:
\begin{lstlisting}
class B {
    static void procB1() {
        A.procA()  // no forward declaration required ...
        B.procB2() // ... same here
    }
    static void procB2() { /* ... */ }
}
class A {
    static void procA() { /* ... */ }
}
\end{lstlisting}
This works because the \textit{context analyzer} of the compiler works in several phases:
\begin{enumerate}
	\item Class symbols are registered in global scope.
	\item Class signatures are analyzed (attributes and base class).
	\item Class inheritance is verified (check for cycles).
	\item Class member symbols are registred in respective class scope (procedures, variables, etc.).
	\item Procedure code is analyzed.
\end{enumerate}


%----------------------------------------------------------------------------------------
%	COMPILER
%----------------------------------------------------------------------------------------

\chapter{Compiler}


%----------------------------------------------------------------------------------------
%	COMMAND LINE TOOL
%----------------------------------------------------------------------------------------

\section{Command Line Tool}

The compiler can be used as command line tool. The appropriate program is named \xxc.
Enter \texttt{xxc help} in a command line to see the manual pages.

In contrast to most other command line tools, the commands for \xxc don't have the `-' prefix.
Instead the command options use this prefix. Here is an example:
\begin{lstlisting}
xxc compile -f FILE1 -f FILE2 -O
\end{lstlisting}
The above command line uses the \texttt{compile} command with the flags `-f' and `-O'.


%----------------------------------------------------------------------------------------
%	VIRTUAL MACHINE
%----------------------------------------------------------------------------------------

\chapter{Virtual Machine}

The \textsc{\xiexie Virtual Machine} (XVM) is a separated program (named \xvm), written in pure C99.


%----------------------------------------------------------------------------------------
%	EXECUTING PROGRAMS
%----------------------------------------------------------------------------------------

\section{Executing Programs}

To execute (or run) a virtual program, just enter the filename of an \texttt{*.xbc} file into the \xvm:
\begin{lstlisting}
xvm HelloWorld.xbc
\end{lstlisting}




\end{document}


