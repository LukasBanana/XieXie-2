;
; Core.xasm
; 
; This file is part of the "XieXie 2.0 Project" (Copyright (c) 2014 by Lukas Hermanns)
; See "LICENSE.txt" for license information.
;

; Export all global addresses
;.pragma("export all")

; ------- Common -------

; Object new(int size, int typeID, int vtableAddr)
new:
	ldw $ar, ($lb) -4	; load argument 'size' (must include 12 bytes for reference counter, type-id, and vtable)
	push $ar
	insc AllocMem		; allocate memory for object and get object reference (ar)
	
	mov $r1, 1			; initialize reference counter to 1
	stw $r1, ($ar) 0	; write reference counter to object
	
	ldw $r1, ($lb) -8	; load argument 'typeID'
	stw $r1, ($ar) 4	; write type-id to object
	
	ldw $r1, ($lb) -12	; load argument 'vtableAddr' (address to vtable for the object)
	stw $r1, ($ar) 8	; write vtable address to object
	
	ret 3				; return object reference (ar)

; void inc_ref(Object this)
inc_ref:
	; check for null pointer
	mov $cf, $xr			; compare: this = null
	je .end
		; increment reference
		ldw $r0, ($xr) 0	; load reference counter from object
		inc $r0				; increment reference counter
		stw $r0, ($xr) 0	; write reference counter back to object
	.end:
	ret

; void dec_ref(Object this)
dec_ref:
	; check for null pointer
	mov $cf, $xr			; compare: this = null
	je .end
	
	; check: ref-count = 1
	ldw $r0, ($xr) 0		; load reference counter from object
	sub $cf, $r0, 1			; check if reference is 1
	je .rel					; release object
		dec $r0				; decrement reference counter
		stw $r0, ($xr) 0	; write reference counter back to object
		ret
	.rel:
	
	; load d'tor address
	ldw $r0, ($xr) 8		; load vtable address
	ldw $r0, ($r0) 0		; load release procedure address
	
	; call d'tor
	push $xr				; store $xr
	call $r0				; call d'tor 'release(this)'
	;pop $xr				; restore $xr
	
	; free memory
	;push $xr				; push this pointer again as argument onto stack
	insc FreeMem			; delete object 'FreeMem(this)'
	
	.end:
	ret

; Object dynamic_cast(Object obj, int baseTypeID, int castNumSubClasses)
dynamic_cast:
	ldw $cf, ($lb) -4		; load object reference 'obj'
	
	; check for null pointer
	je .end					; compare: obj = null
	
	; load type ids
	mov $ar, $cf
	ldw $r1, ($ar) 4		; load type-id of 'obj'
	ldw $r2, ($lb) -8		; load type-id 'baseTypeID'
	ldw $r3, ($lb) -12		; load number of sub classes 'castNumSubClasses'
	add $r3, $r3, $r2		; calculate: baseTypeID + castNumSubClasses
	
	; compare type-ids
	cmp $r2, $r1			; compare: baseTypeID > obj.typeID
	jg .end
		cmp $r1, $r3		; compare: obj.typeID > (baseTypeID + castNumSubClasses)
		jg .end
			ret 3			; return object reference (ar)
			
	; class-cast exception
	.end:
	mov $ar, 0				; return null pointer
	ret 3

; String String.copy_literal(String literal)
String.copy_literal:
	; allocate new "String" object
	ldw $r0, ($lb) -4					; load address of string literal
	push 24
	insc AllocMem						; allocate memory for new string instance
	mov $xr, $ar						; store pointer to new string object
	push $r0
	call CString.Pinit,R@String?source	; call copy constructor
	mov $ar, $xr						; restore and return pointer to new string object
	ret 1


; ------- Object Class -------

; Object:
;	int refCount	(0)
;	int typeID		(4)
;	int vtableAddr	(8)

; void Object.release(Object this)
CObject.Prelease:

; void Object.init(Object this)
CObject.Pinit:
	ret

; int Object.refCount(Object this)
CObject.PrefCount:
	ldw $ar, ($xr) 0	; load and return reference counter of 'this'
	ret

; int Object.typeID(Object this)
CObject.PtypeID:
	ldw $ar, ($xr) 4	; load and return type-id of 'this'
	ret

; bool Object.equals(Object this, Object rhs)
CObject.Pequals,R@Object?rhs:
	; check for null pointer
	ldw $r0, ($lb) -4	; load object reference 'rhs'
	mov $cf, $r0		; compare: rhs = null
	je .end
	
	; load type ids
	ldw $r1, ($xr) 4	; load type-id of 'this'
	ldw $r2, ($r0) 4	; load type-id of 'rhs'
	
	; check: this.typeID = rhs.typeID
	cmp $r1, $r2		; compare type-id of both object references
	jne .end
		mov $ar, 1		; return true
		ret 1
	.end:
	mov $ar, 0			; return false
	ret 1

; TODO: currently returns null pointer !!!
; String Object.toString(Object this)
CObject.PtoString:
	mov $ar, 0	; return null pointer
	ret

; int Object.pointer(Object this)
CObject.Ppointer:
	add $ar, $xr, 12	; return pointer to first member variables of derived class
	ret

Object.vtable:
	.word @CObject.Prelease
	.word @CObject.Pinit
	.word @CObject.PtypeID
	.word @CObject.PrefCount
	.word @CObject.Pequals,R@Object?rhs
	.word @CObject.PtoString
	.word @CObject.Ppointer


; ------- String Class -------

; String:
;	Object	super	( 0)
;	int		size	(12) <- number of characters (bytes)
;	int		bufSize	(16) <- actual number of characters (bytes)
;	int		buffer	(20)

; void String.release(Object this)
CString.Prelease:
	; free string buffer
	ldw $r0, ($xr) 20	; load pointer to string buffer
	push $r0
	insc FreeMem		; delete string buffer
	ret

; void String.init(Object this)
CString.Pinit:
	; this.size := 0
	mov $r0, 0
	stw $r0, ($xr) 12
	
	; initialize string buffer with 16 elements
	mov $r1, 16
	stw $r1, ($xr) 16
	
	; allocate string buffer
	push 16
	insc AllocMem		; allocate 16 bytes
	stw $ar, ($xr) 20	; store pointer to buffer in string instance
	
	; initialize string buffer with null terminator
	stw $r0, ($ar) 0	; this.pointer[0] := 0
	ret

; void String.init(String this, String source)
CString.Pinit,R@String?source:
	; copy first 20 bytes from literal
	ldw $r0, ($lb) -4	; load address of string literal
	push 20				; push size of 20 bytes (excluding the '.buffer' address)
	push $r0			; push source address of original string literal
	push $xr			; push this pointer as destination address
	insc CopyMem
	
	; allocate buffer for new string
	ldw $r1, ($r0) 12	; load 'String.size'
	inc $r1				; increase size for null terminator
	push $r1
	insc AllocMem		; allocate buffer
	stw $ar, ($xr) 20	; write buffer address to new string object
	
	; copy string buffer from literal
	ldw $r0, ($r0) 20	; load buffer address from literal
	push $r1			; push buffer size
	push $r0			; push buffer address of literal
	push $ar			; push buffer address of new string
	insc CopyMem
	ret 1

; String String.toString(Object this)
CString.PtoString:
	mov $ar, $xr	; just return this pointer
	ret

; String String.copy(String this)
CString.Pcopy:
	; allocate new String instance
	push @String.vtable					; push String vtable
	push 1								; push String type-id
	push 24								; push String size
	call new							; allocate new String
	pop $r1
	
	; call String's copy c'tor
	ldw $r0, ($lb) -4					; load this pointer
	push $r1							; push first as back-up
	push $r1							; push second as argument
	mov $xr, $r0						; override this pointer with reference to new String instance
	call CString.Pinit,R@String?source	; call String copy constructor
	
	; return new String instance
	pop $ar								; get return value from back-up $r0 on stack
	ret

; int String.size(String this)
CString.Psize:
	ldw $ar, ($xr) 12	; load and return member this.size
	ret

; void String.resize(String this, int size)
CString.Presize,I?size:
	; ...
	ret 1

; bool String.empty(String this)
CString.Pempty:
	ldw $cf, ($xr) 12	; load member this.size and compare this.size = 0
	je .empty
		mov $ar, 0		; return false
		ret
	.empty:
	mov $ar, 1			; return true
	ret

; String String.append(String this, String rhs)
CString.Pappend,R@String?rhs:
	; ...
	ret 1

; String String.append(String this, Object rhs)
CString.Pappend,R@Object?rhs:
	; ...
	ret 1

; void String.setChar(String this, int pos, int char)
CString.PsetChar,I?pos,I?char:
	; ...
	ret 2

; int String.getChar(String this, int pos)
CString.PgetChar,I?pos:
	; ...
	mov $ar, 0 ; !!!
	ret 1

; int String.pointer(Object this)
CString.Ppointer:
	ldw $ar, ($xr) 20	; load and return member this.buffer
	ret

String.vtable:
	.word @CString.Prelease
	.word @CString.Pinit
	.word @CObject.PtypeID
	.word @CObject.PrefCount
	.word @CObject.Pequals,R@Object?rhs
	.word @CString.PtoString
	.word @CString.Ppointer
	.word @CString.Pinit,R@String?source
	.word @CString.Pcopy
	.word @CString.Psize
	.word @CString.Presize,I?size
	.word @CString.Pempty
	.word @CString.Pappend,R@String?rhs
	.word @CString.Pappend,R@Object?rhs
	.word @CString.PsetChar,I?pos,I?char
	.word @CString.PgetChar,I?pos


; ------- Array Class -------
; built-in array for objects

; Array:
;	Object	super	( 0)
;	int		size	(12) <- number of entries
;	int		bufSize	(16) <- actual number of entries
;	int		buffer	(20)

; void Array.release(Object this)
CArray.Prelease:
	; load object members
	ldw $r0, ($xr) 12	; load this.size
	ldw $r1, ($xr) 20	; load pointer to array buffer
	
	; de-reference all objects in array
	mov $xr, $r1		; set iterator to pointer: it := this.buffer
	sll $r0, $r0, 2		; calculate: size := this.size * 4
	add $r0, $r0, $xr	; determine end iterator: itEnd := it + size
	.loop:
	cmp $xr, $r0		; compare: it >= itEnd
	jge .end
		; store registers
		push $xr
		push $r0
		push $r1
		
		; decrement reference counter
		call dec_ref
		
		; restore registers
		pop $r1
		pop $r0
		pop $xr
	add $xr, $xr, 4		; it += 4
	jmp .loop
	.end:
	
	; free array buffer
	push $r1
	insc FreeMem		; delete array buffer
	ret

; void Array.init(Object this)
CArray.Pinit:
; void PrimArray.init(Object this)
CPrimArray.Pinit:
	; this.size := 0
	mov $r0, 0
	stw $r0, ($xr) 12
	
	; initialize array buffer with 16 elements
	mov $r1, 16
	stw $r1, ($xr) 16
	
	; allocate array buffer
	push 64
	insc AllocMem		; allocate 16*4 bytes
	stw $ar, ($xr) 20	; store pointer to buffer in array instance
	ret

; void Array.init(Array this, int size)
CArray.Pinit,I?size:
	; ...
	ret 1

Array.vtable:
	.word @CArray.Prelease
	.word @CArray.Pinit
	.word @CObject.PtypeID
	.word @CObject.PrefCount
	.word @CArray.Pequals,R@Object?rhs
	.word @CArray.PtoString
	.word @CArray.Ppointer
	.word @CArray.Pinit,I?size
	.word @CArray.Pcopy
	.word @CArray.Psize
	.word @CArray.Presize,I?size
	.word @CArray.Pempty
	.word @CArray.Padd,R@Object?entry
	.word @CArray.Premove,I?pos


; ------- PrimArray Class -------
; built-in array for built-in types 'int' and 'float' and for all arrays of 'weak-references'

; PrimArray:
;	Object	super	( 0)
;	int		size	(12) <- number of entries
;	int		bufSize	(16) <- actual number of entries
;	int		buffer	(20)

; todo...

PrimArray.vtable:
	.word @PrimArray.Prelease
	.word @PrimArray.Pinit
	.word @CObject.PtypeID
	.word @CObject.PrefCount
	.word @PrimArray.Pequals,R@Object?rhs
	.word @PrimArray.PtoString
	.word @PrimArray.Ppointer
	.word @PrimArray.Pinit,I?size
	.word @PrimArray.Pcopy
	.word @PrimArray.Psize
	.word @PrimArray.Presize,I?size
	.word @PrimArray.Pempty
	.word @PrimArray.Padd,R@Object?entry
	.word @PrimArray.Premove,I?pos


; ------- BoolArray Class -------
; built-in array for 'bool'

; BoolArray:
;	Object	super	( 0)
;	int		size	(12) <- number of entries
;	int		bufSize	(16) <- actual number of entries
;	int		buffer	(20)

; void BoolArray.release(Object this)
CBoolArray.Prelease:
	; free string buffer
	ldw $r0, ($xr) 20	; load pointer to array buffer
	push $r0
	insc FreeMem		; delete array buffer
	ret

; void BoolArray.init(Object this)
CBoolArray.Pinit:
	; ...
	ret

; void BoolArray.init(BoolArray this, int size)
CBoolArray.Pinit,I?size:
	; initialize array members
	ldw $cf, ($lb) -8		; load 'size'
	stw $cf, ($xr) 12		; write: this.size := size
	stw $cf, ($xr) 16		; write: this.bufSize := size
	
	; determine buffer size (in bytes): numBytes := (size + 7) >> 3
	add $cf, $cf, 7
	slr $cf, $cf, 3
	
	; allocate array buffer
	push $cf
	insc AllocMem			; allocate buffer
	stw $ar, ($xr) 20		; store pointer to buffer in array instance
	
	; initialize buffer with zeros
	mov $r0, 0
	.loop:
	jle .end				; compare: numBytes <= 0
		stw $r0, ($ar) 0	; store zero at (*buffer)
		inc $ar				; buffer++
	dec $cf					; numBytes--
	jmp .loop
	.end:
	ret 1

BoolArray.vtable:
	.word @CBoolArray.Prelease
	.word @CBoolArray.Pinit
	.word @CObject.PtoString
	.word @CBoolArray.Pinit,I?size

