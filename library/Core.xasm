;
; Core.xasm
; 
; This file is part of the "XieXie 2.0 Project" (Copyright (c) 2014 by Lukas Hermanns)
; See "LICENSE.txt" for license information.
;

; Export all global addresses
.pragma("export all")

; ------- Common -------

; Object new(int size, int typeID, int vtableAddr)
new:
	ldw $ar, ($lb) -4	; load argument 'size' (must include 12 bytes for reference counter, type-id, and vtable)
	push $ar
	insc AllocMem		; allocate memory for object and get object reference (ar)
	
	mov $r1, 1			; initialize reference counter to 1
	stw $r1, ($ar) 0	; write reference counter to object
	
	ldw $r1, ($lb) -8	; load argument 'typeID'
	stw $r1, ($ar) 4	; write type-id to object
	
	ldw $r1, ($lb) -12	; load argument 'vtableAddr' (address to vtable for the object)
	stw $r1, ($ar) 8	; write vtable address to object
	
	ret 1				; return object reference (ar)

; void inc_ref(Object obj)
inc_ref:
	; check for null pointer
	ldw $r0, ($lb) -4		; load object reference 'obj'
	mov $cf, $r0			; compare: obj = null
	je .end
		; increment reference
		ldw $r1, ($r0) 0	; load reference counter from object
		inc $r1				; increment reference counter
		stw $r1, ($r0) 0	; write reference counter back to object
	.end:
	ret 1

; void dec_ref(Object obj)
dec_ref:
	; check for null pointer
	ldw $r0, ($lb) -4		; load object reference 'obj'
	mov $cf, $r0			; compare: obj = null
	jne .end
	
	; check: ref-count = 1
	ldw $r1, ($r0) 0		; load reference counter from object
	sub $cf, $r1, 1			; check if reference is 1
	je .rel					; release object
		dec $r1				; decrement reference counter
		stw $r1, ($r0) 0	; write reference counter back to object
		ret 1
	.rel:
	
	; load d'tor address
	ldw $r1, ($r0) 8		; load vtable address
	ldw $r1, ($r1) 0		; load release procedure address
	
	; call d'tor
	push $r0				; store $r0
	push $r0				; push this pointer as argument onto stack
	call $r1				; call d'tor 'release(this)'
	;pop $r0				; restore $r0
	
	; free memory
	;push $r0				; push this pointer again as argument onto stack
	insc FreeMem			; delete object 'FreeMem(this)'
	
	.end:
	ret 1

; Object dynamic_cast(Object obj, int baseTypeID, int numSubClasses)
dynamic_cast:
	ldw $cf, ($lb) -4		; load object reference 'obj'
	
	; check for null pointer
	je .end					; compare: obj = null
	
	; load type ids
	mov $ar, $cf
	ldw $r1, ($ar) 4		; load type-id of 'obj'
	ldw $r2, ($lb) -8		; load type-id 'baseTypeID'
	ldw $r3, ($lb) -12		; load number of sub classes 'numSubClasses'
	add $r3, $r3, $r2		; calculate: baseClass.typeID + obj.numSubClasses
	
	; compare type-ids
	cmp $r2, $r1			; compare: baseClass.typeID > obj.typeID
	jg .end
		cmp $r1, $r3		; compare: obj.typeID > (baseClass.typeID + obj.numSubClasses)
		jg .end
			ret 3			; return object reference (ar)
			
	; class-cast exception
	.end:
	mov $ar, 0				; return null pointer
	ret 3


; ------- Object Class -------

; Object:
;	int refCount	(0)
;	int typeID		(4)
;	int vtableAddr	(8)

; void Object.release(Object this)
CObject.Prelease,R@Object:

; void Object.init(Object this)
CObject.Pinit,R@Object:
	ret 1

; int Object.typeID(Object this)
CObject.PtypeID,R@Object:
	ldw $ar, ($lb) -4	; load this pointer
	ldw $ar, ($ar) 4	; load and return type-id of 'this'
	ret 1

; int Object.refCount(Object this)
CObject.PrefCount,R@Object:
	ldw $ar, ($lb) -4	; load this pointer
	ldw $ar, ($ar) 0	; load and return reference counter of 'this'
	ret 1

; bool Object.equals(Object this, Object rhs)
CObject.Pequals,R@Object:
	; check for null pointer
	ldw $r1, ($lb) -8	; load object reference 'rhs'
	mov $cf, $r1		; compare: rhs = null
	je .end
	
	; load type ids
	ldw $r0, ($lb) -4	; load this pointer
	ldw $r2, ($r0) 4	; load type-id of 'this'
	ldw $r3, ($r1) 4	; load type-id of 'rhs'
	
	; check: this.typeID = rhs.typeID
	cmp $r2, $r3		; compare type-id of both object references
	jne .end
		mov $ar, 1		; return true
		ret 2
	.end:
	mov $ar, 0			; return false
	ret 2

; Object Object.copy(Object this)
CObject.Pcopy,R@Object:
	push @Object.vtable		; push Object vtable
	push 0					; push Object type-id
	push 12					; push Object size
	call new				; allocate new empty object
	ret 1

; TODO: currently returns null pointer !!!
; String Object.toString(Object this)
CObject.PtoString,R@Object:
	mov $ar, 0	; return null pointer
	ret 1

Object.vtable:
	.word @CObject.Prelease,R@Object
	.word @CObject.Pinit,R@Object
	.word @CObject.PtoString,R@Object


; ------- String Class -------

; String:
;	Object	super	( 0)
;	int		size	(12) <- number of characters (bytes)
;	int		bufSize	(16) <- actual number of characters (bytes)
;	int		buffer	(20)

; void String.release(Object this)
CString.Prelease,R@Object:
	; free string buffer
	ldw $r0, ($lb) -4	; load this pointer
	ldw $r0, ($r0) 20	; load pointer to string buffer
	push $r0
	insc FreeMem		; delete string buffer
	ret 1

; void String.init(Object this)
CString.Pinit,R@Object:
	; initialize string with buffer: byte[1] := { '\0' }
	ldw $r0, ($lb) 4	; load this pointer
	
	; this.size := 0
	mov $r1, 0
	stw $r1, ($r0) 12
	
	; initialize string buffer with 16 elements
	mov $r2, 16
	stw $r2, ($r0) 16
	
	; allocate string buffer
	push 16
	insc AllocMem		; allocate 16 bytes
	stw $ar, ($r0) 20	; store pointer to buffer in string instance
	
	; initialize string buffer with null terminator
	stw $r1, ($ar) 0	; this.pointer[0] := 0
	ret 1

; void String.init(String this, String copySource)
CString.Pinit,R@String,R@String:
	; ...
	ret 2

; String String.toString(Object this)
CString.PtoString,R@Object:
	ret 0	; just return input argument

; String String.copy(String this)
CString.Pcopy,R@String:
	; allocate new String instance
	push @String.vtable						; push String vtable
	push 1									; push String type-id
	push 24									; push String size
	call new								; allocate new String
	pop $r1
	
	; call String's copy c'tor
	ldw $r0, ($lb) -4						; load this pointer
	push $r1								; push first as back-up
	push $r0								; push this pointer
	push $r1								; push second as argument
	call CString.Pinit,R@String,R@String
	pop $ar									; return new String instance (from back-up $r0 on stack)
	ret 1

; int String.size(String this)
CString.Psize,R@String:
	ldw $ar, ($lb) -4	; load this pointer
	ldw $ar, ($ar) 12	; load and return member this.size
	ret 1

; void String.resize(String this, int size)
CString.Presize,R@String,I:
	; ...
	ret 2

; bool String.empty(String this)
CString.Pempty,R@String:
	ldw $cf, ($lb) -4	; load this pointer
	ldw $cf, ($cf) 12	; load member this.size and compare this.size = 0
	je .empty
		mov $ar, 0		; return false
		ret 1
	.empty:
	mov $ar, 1			; return true
	ret 1

; String String.add(String this, String rhs)
CString.Padd,R@String,R@String:
	; ...
	ret 2

; void String.setChar(String this, int pos, int char)
CString.PsetChar,R@String,I,I:
	; ...
	ret 3

; int String.getChar(String this, int pos)
CString.PgetChar,R@String,I:
	; ...
	ret 2

; int String.pointer(String this)
CString.Ppointer,R@String:
	ldw $ar, ($lb) -4	; load this pointer
	ldw $ar, ($ar) 20	; load and return member this.buffer
	ret 1

String.vtable:
	.word @CString.Prelease,R@Object
	.word @CString.Pinit,R@Object
	.word @CString.PtoString,R@Object
	.word @CString.Pinit,R@String,R@String
	.word @CString.Pcopy,R@String
	.word @CString.Psize,R@String
	.word @CString.Presize,R@String,I
	.word @CString.Pempty,R@String
	.word @CString.Padd,R@String,R@String
	.word @CString.PsetChar,R@String,I,I
	.word @CString.PgetChar,R@String,I


; ------- Array Class -------
; built-in array for objects

; Array:
;	Object	super	( 0)
;	int		size	(12) <- number of entries
;	int		bufSize	(16) <- actual number of entries
;	int		buffer	(20)

; void Array.release(Object this)
CArray.Prelease,R@Object:
	; load object members
	ldw $r0, ($lb) -4	; load this pointer
	ldw $r1, ($r0) 12	; load this.size
	ldw $r2, ($r0) 20	; load pointer to string buffer
	
	; de-reference all objects in array
	mov $r0, $r2		; set iterator to pointer: it := this.buffer
	sll $r1, $r1, 2		; calculate: size := this.size * 4
	add $r1, $r1, $r0	; determine end iterator: itEnd := it + size
	.loop:
	cmp $r0, $r1		; compare: it >= itEnd
	jge .end
		; store registers
		push $r0
		push $r1
		push $r2
		
		; decrement reference counter
		push $r0
		call dec_ref
		
		; restore registers
		pop $r2
		pop $r1
		pop $r0
	add $r3, $r3, 4		; it += 4
	jmp .loop
	.end:
	
	; free array buffer
	push $r2
	insc FreeMem		; delete string buffer
	ret 1

; void Array.init(Object this)
CArray.Pinit,R@Object:
	; ...
	ret 1

; void Array.init(Array this, int size)
CArray.Pinit,R@Array,I:
	; ...
	ret 2

Array.vtable:
	.word @CArray.Prelease,R@Object
	.word @CArray.Pinit,R@Object
	.word @CObject.PtoString,R@Object
	.word @CArray.Pinit,R@Array,I


; ------- PrimArray Class -------
; built-in array for built-in types 'int' and 'float' and for all arrays of 'weak-references'

; PrimArray:
;	Object	super	( 0)
;	int		size	(12) <- number of entries
;	int		bufSize	(16) <- actual number of entries
;	int		buffer	(20)


; ------- BoolArray Class -------
; built-in array for 'bool'

; BoolArray:
;	Object	super	( 0)
;	int		size	(12) <- number of entries
;	int		bufSize	(16) <- actual number of entries
;	int		buffer	(20)

; void BoolArray.release(Object this)
CBoolArray.Prelease,R@Object:
	; free string buffer
	ldw $r0, ($lb) -4	; load this pointer
	ldw $r0, ($r0) 20	; load pointer to array buffer
	push $r0
	insc FreeMem		; delete array buffer
	ret 1

; void BoolArray.init(Object this)
CBoolArray.Pinit,R@Object:
	; ...
	ret 1

; void BoolArray.init(BoolArray this, int size)
CBoolArray.Pinit,R@BoolArray,I:
	; initialize array members
	ldw $r0, ($lb) -4		; load this pointer
	ldw $cf, ($lb) -8		; load 'size'
	stw $cf, ($r0) 12		; write: this.size := size
	stw $cf, ($r0) 16		; write: this.bufSize := size
	
	; determine buffer size (in bytes): numBytes := (size + 7) >> 3
	add $cf, $cf, 7
	slr $cf, $cf, 3
	
	; allocate array buffer
	push $cf
	insc AllocMem			; allocate buffer
	stw $ar, ($r0) 20		; store pointer to buffer in array instance
	
	; initialize buffer with zeros
	mov $r2, 0
	.loop:
	jle .end				; compare: numBytes <= 0
		stw $r2, ($ar) 0	; store zero at (*buffer)
		inc $ar				; buffer++
	dec $cf					; numBytes--
	jmp .loop
	.end:
	ret 2

BoolArray.vtable:
	.word @CBoolArray.Prelease,R@Object
	.word @CBoolArray.Pinit,R@Object
	.word @CObject.PtoString,R@Object
	.word @CBoolArray.Pinit,R@BoolArray,I

